---
title: "Análise de Séries Temporais - Trabalho 2"
author: "Davi Guerra Alves - Henrique Oliveira Dumay"
date: '2023-07-02'
output: pdf_document
header-includes:
 \usepackage{float}
---


```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
lapply(c('dplyr','lubridate','Mcomp','forecast','tseries','ggplot2','ggpubr'),require,character.only=TRUE)
# Dados
data(M3)
id <- 1686
```


```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.pos = 'H')
```

# Apresentação

A série analisada consiste na série número `r id` pertencente ao banco de dados da competição de previsão M3, disponível no pacote *Mcomp* do software R. A série descreve o número de carregamentos com código _TD-AUTOUNITS_, mensalmente, de outubro de 1984 a setembro de 1993. 

```{r, fig.align="center",fig.cap='Comportamento da série ao longo do tempo',echo=FALSE}
M3[[id]] %>% plot(xlab="Ano", ylab="n.º de carregamentos")
```

# Decomposição MSTL

```{r,fig.align="center",fig.cap='Decomposição MSTL', echo = FALSE}
mstl(M3[[id]]$x, s.window= c(12)) %>% 
  plot(main="Série Original")
```
A decomposição MSTL mostra os componentes de tendência, sazonalidade e erro da série estudada. Percebe-se a presença de uma tendência crescente, com múltiplas sazonalidades que apesentam mudança do comportamento ao longo do tempo. É possível observar, graficamente, um alargamento da sazonalidade ao fim da série quando comparando ao início da série. 

# Modelos ARIMA

A presença do componente de tendência explicita a não-estacionaridade da série original.A função ndiffs() é utilizada para estimar o número de diferenças exigidas para tornar a série estacionária por meio de um teste de raíz unitária, com a hipótese nula de que a série tem raízes estacionárias contra a hipótese alternativa de que a série tem raíz unitária. O teste retorna o menor número de diferenças exigidas para o teste em um nível de significância de 95%. Já a função nsdiffs() utiliza testes de raíz unitária para determinar o número de diferenças sazonais para tornar a série estacionária. 

Com o uso das funções acima, obteve-se o valor para $d = 1$ e $D = 0$. Os modelos candidatos terão a forma:

$$SARIMA(p, 1, q) \times (P, 0, Q)_{12}$$

```{r, echo = FALSE, include = FALSE, echo = FALSE}
M3[[id]]$x %>%
  ndiffs()             # d = 1

M3[[id]]$x %>%
  diff() %>%
  nsdiffs()            # D = 0

serie_dif <- M3[[id]]$x %>% 
  diff() 
```

A estacionariedade da série pode ser testada utilizando o teste Kwiatkowski-Phillips-Schmidt-Shin (KPSS), com a hipótese nula de que a série é estacionária. O teste resulta em um valor de `r kpss.test(serie_dif)[[1]]`, com p-valor de `r kpss.test(serie_dif)[[3]]`, que não nos permite rejeitar a hipótese nula a um nível de significância $\alpha = 0,05$.

```{r, include = FALSE}
kpss.test(serie_dif)
```
Consideramos que a série é, agora, estacionária, observamos os gráficos da função de autocorrelação (ACF) e da função de autocorrelação parcial (PACF) em busca de possíveis autocorrelações entre os diferentes atrasos da série. Os gráficos a seguir ilustram a série diferenciada, assim como os gráficos das funções de ACF e PACF.

```{r, fig.align="center",fig.cap='Gráficos ACF e PACF', echo = FALSE}

par(mfrow=c(3,1),mar=c(4, 3, 3, 1) + 0.5)
plot(serie_dif,main="Série diferenciada")
acf(serie_dif, lag = 5*12, main="ACF") 
pacf(serie_dif, lag = 5*12, main="PACF")
```
Dos gráficos apresentados, pode-se afirmar que a série diferenciada não apresenta um padrão claro de autocorrelações simples e sazonais que permita inferir diretamente a modelagem. Neste sentido, serão testados valores diferentes para *p*, *P*, *q* e *Q* e os diferentes modelos serão comparados por meio do critério AIC.

Para os diferentes valores de $(p,q,P,Q)$ teremos:

```{r, echo = FALSE}
melhor_AICc = Inf
for (P in 0:1) { 
  for (Q in 0:1) {
    for (p in 0:3) { 
      for (q in 0:3) {
        fit = Arima(M3[[id]]$x, order=c(p,1,q), seasonal=c(P,0,Q))
        if (fit$aicc < melhor_AICc) { 
          melhor_AICc = fit$aicc
          cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =", fit$aicc, "\n")
        }
      }
    }
  }
}
```
O modelo com menor AICc foi o $SARIMA(1,1,1) \times (1,0,1)_{12}$. 

Os coeficientes do modelo proposto, portanto, serão obtidos do cálculo da função Arima com o modelo acima proposto. Os coeficientes do modelo terão a seguinte forma:

```{r, include = FALSE}
fit_arima <- Arima(M3[[id]]$x, order=c(1,1,1), seasonal=c(1,0,1))
fit_arima
```


$$\phi_1 = 0,3152; \theta_1 = -0,9218; \varphi = 0,9606; \vartheta = -0,7359$$
Utilizaremos o modelo ARIMA acima definido com a transformação de Box-Cox com o objetivo de estabilizar os diferentes tipos de variação ao longo do tempo. O novo modelo tem os seguintes coeficientes:

```{r, include = FALSE}
fit_arima_boxcox = Arima(M3[[id]]$x,order=c(1,1,1),seasonal=c(1,0,1), lambda = 'auto')
fit_arima_boxcox
```
$$\phi_1 = 0,2756; \theta_1 = -0,9209; \varphi = 0,9994; \vartheta = -0,9653$$

## Análise de Resíduos

Os resíduos dos modelos descritos apresentam o seguinte comportamento gráfico

```{r fig.align="center",fig.cap='Resíduos', echo = FALSE}
par(mfrow=c(1,2))
plot(fit_arima$residuals, ylab = "Resíduos", xlab = "")
plot(fit_arima_boxcox$residuals, ylab = "Resíduos", xlab = "")
```
Os resíduos precisam ser estacionários, independentes e normalmente distribuiídos. Essas hipóteses serão testadas conforme se segue.

A estacionaridade será testada a partir do teste Kwiatkowski-Phillips-Schmidt-Shin (KPSS), com a hipótese nula de que a série é estacionária. O teste para o modelo $SARIMA(1,1,1) \times (1,0,1)_{12}$ e para o mesmo modelo, utilizando a transformação de Box-Cox:

| Modelo | KPSS | P-valor |
|:---:|:---:|:---:|
| SARIMA sem Box-Cox | `r kpss.test(fit_arima$residuals)[[1]]` | `r kpss.test(fit_arima$residuals)[[3]]` |
| SARIMA com Box-Cox | `r kpss.test(fit_arima_boxcox$residuals)[[1]]` | `r kpss.test(fit_arima_boxcox$residuals)[[3]]` |

O teste de independência dos resíduos é realizado a partir do teste Ljung-Box, com a hipótese $H_0$ de que os resíduos são idenpendentemente distribuídos. O teste apresenta os seguintes valores para os dois modelos:

| Modelo | Chi-Quadrado | Graus de liberdade | P-valor |
|:---:|:---:|:---:|:---:|
| SARIMA sem Box-Cox | `r Box.test(fit_arima$residuals, lag = 15, type ="Ljung-Box")[[1]]` | `r Box.test(fit_arima$residuals, lag = 15, type ="Ljung-Box")[[2]]` | `r Box.test(fit_arima$residuals, lag = 15, type ="Ljung-Box")[[3]]` |
| SARIMA com Box-Cox | `r Box.test(fit_arima_boxcox$residuals, lag = 15, type ="Ljung-Box")[[1]]` | `r Box.test(fit_arima_boxcox$residuals, lag = 15, type ="Ljung-Box")[[2]]` | `r Box.test(fit_arima_boxcox$residuals, lag = 15, type ="Ljung-Box")[[3]]` |

```{r, include = FALSE}
Box.test(fit_arima$residuals, lag = 15, type ="Ljung-Box")[[3]]
```
Os resultados acima mostram que a independência dos resíduos pode ser rejeitada ao nível de significância de 5% no modelo que utiliza a transformação de Box-Cox, enquanto não pode ser rejeitada no modelo SARIMA natural. 

A normalidade dos resíduos é testada com o teste Shapiro-Wilk de Normalidade, com $H_0$ de que os resíduos apresentam distribuição normal. O valor do teste estatístico para os dois modelos trabalhados é:

| Modelo | W | P-valor |
|:---:|:---:|:---:|
| SARIMA sem Box-Cox | `r shapiro.test(fit_arima$residuals)[[1]]` | `r shapiro.test(fit_arima$residuals)[[2]]` |
| SARIMA com Box-Cox | `r shapiro.test(fit_arima_boxcox$residuals)[[1]]` | `r shapiro.test(fit_arima_boxcox$residuals)[[2]]` |

Do resultado acima, não se pode rejeitar a hipótese de normalidade dos resíduos de ambos os modelos. 

```{r, include = FALSE}
shapiro.test(fit_arima$residuals)[[2]]
```
## Previsões

As previsões dos modelos:

```{r, fig.align="center", fig.cap="Previsões dos modelos ARIMA", echo = FALSE}
arima_layout <- layout(matrix(c(1,2),ncol=1), heights=c(20,20), TRUE)
fit_arima %>% forecast(h=24, level=c(80, 95)) %>% plot(xlab = "Arima(1,1,1)x(1,0,1)[12]", main = "")
fit_arima_boxcox %>% forecast(h=24, level=c(80, 95)) %>% plot(xlab = "Arima(1,1,1)x(1,0,1)[12] com Box-Cox", main = "")
```
