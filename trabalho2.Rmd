---
title: "Análise de Séries Temporais - Trabalho 2"
author: "Davi Guerra Alves - Henrique Oliveira Dumay"
date: '2023-07-02'
output: pdf_document
header-includes:
 \usepackage{float}
---


```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
lapply(c('dplyr','lubridate','Mcomp','forecast','tseries','ggplot2','ggpubr'),require,character.only=TRUE)
# Dados
data(M3)
id <- 1686
```


```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.pos = 'H')
```

# Apresentação

A série analisada consiste na série número `r id` pertencente ao banco de dados da competição de previsão M3, disponível no pacote *Mcomp* do software R. A série descreve o número de carregamentos com código _TD-AUTOUNITS_, mensalmente, de outubro de 1984 a setembro de 1993. 

```{r, fig.align="center",fig.cap='Comportamento da série ao longo do tempo',echo=FALSE}
M3[[id]] %>% plot(xlab="Ano", ylab="n.º de carregamentos")
```

# Decomposição MSTL

```{r,fig.align="center",fig.cap='Decomposição MSTL', echo = FALSE}
mstl(M3[[id]]$x, s.window= c(12)) %>% 
  plot(main="Série Original")
```
A decomposição MSTL mostra os componentes de tendência, sazonalidade e erro da série estudada. Percebe-se a presença de uma tendência crescente, com múltiplas sazonalidades que apesentam mudança do comportamento ao longo do tempo. É possível observar, graficamente, um alargamento da sazonalidade ao fim da série quando comparando ao início da série. 

A presença do componente de tendência explicita a não-estacionaridade da série original.A função ndiffs() é utilizada para estimar o número de diferenças exigidas para tornar a série estacionária por meio de um teste de raíz unitária, com a hipótese nula de que a série tem raízes estacionárias contra a hipótese alternativa de que a série tem raíz unitária. O teste retorna o menor número de diferenças exigidas para o teste em um nível de significância de 95%. Já a função nsdiffs() utiliza testes de raíz unitária para determinar o número de diferenças sazonais para tornar a série estacionária. 

Com o uso das funções acima, obteve-se o valor para $d = 1$ e $D = 0$. Os modelos candidatos terão a forma:

$$SARIMA(p, 1, q) \times (P, 0, Q)_{12}$$

```{r, echo = FALSE, include = FALSE, echo = FALSE}
M3[[id]]$x %>%
  ndiffs()             # d = 1

M3[[id]]$x %>%
  diff() %>%
  nsdiffs()            # D = 0

serie_dif <- M3[[id]]$x %>% 
  diff() 
```

A estacionariedade da série pode ser testada utilizando o teste Kwiatkowski-Phillips-Schmidt-Shin (KPSS), com a hipótese nula de que a série é estacionária. O teste resulta em um valor de `r kpss.test(serie_dif)[[1]]`, com p-valor de `r kpss.test(serie_dif)[[3]]`, que não nos permite rejeitar a hipótese nula a um nível de significância $\alpha = 0,05$.

```{r, include = FALSE}
kpss.test(serie_dif)
```
Consideramos que a série é, agora, estacionária, observamos os gráficos da função de autocorrelação (ACF) e da função de autocorrelação parcial (PACF) em busca de possíveis autocorrelações entre os diferentes atrasos da série. Os gráficos a seguir ilustram a série diferenciada, assim como os gráficos das funções de ACF e PACF.

```{r, fig.align="center",fig.cap='Gráficos ACF e PACF', echo = FALSE}

par(mfrow=c(3,1),mar=c(4, 3, 3, 1) + 0.5)
plot(serie_dif,main="Série diferenciada")
acf(serie_dif, lag = 5*12, main="ACF") 
pacf(serie_dif, lag = 5*12, main="PACF")
```
Dos gráficos apresentados, pode-se afirmar que a série diferenciada não apresenta um padrão claro de autocorrelações simples e sazonais que permita inferir diretamente a modelagem. Neste sentido, serão testados valores diferentes para *p*, *P*, *q* e *Q* e os diferentes modelos serão comparados por meio do critério AIC.

Para os diferentes valores de $(p,q,P,Q)$ teremos:

```{r, echo = FALSE}
melhor_AICc = Inf
for (P in 0:1) { 
  for (Q in 0:1) {
    for (p in 0:3) { 
      for (q in 0:3) {
        fit = Arima(M3[[id]]$x, order=c(p,1,q), seasonal=c(P,1,Q))
        if (fit$aicc < melhor_AICc) { 
          melhor_AICc = fit$aicc
          cat("p =",p,", q =",q,", P =",P,", Q =",Q,", AICc =", fit$aicc, "\n")
        }
      }
    }
  }
}
```
O modelo com menor AICc foi o $SARIMA(2,1,3) \times (0,0,1)_{12}$. 

Os coeficientes do modelo proposto, portanto, serão obtidos do cálculo da função Arima com o modelo acima proposto. Os coeficientes do modelo terão a seguinte forma:

```{r, include = FALSE}
fit_arima <- Arima(M3[[id]]$x, order=c(2,1,3), seasonal=c(0,0,1))
fit_arima
```


$$\phi_1 = -0,5572; \phi_2=-0,7207; \theta_1 = 0,0136; \theta_2 = 0,2117; \theta_3=-0,8811; \vartheta=0,4280$$
Utilizaremos o modelo ARIMA acima definido com a transformação de Box-Cox com o objetivo de estabilizar os diferentes tipos de variação ao longo do tempo. O novo modelo tem os seguintes coeficientes:

```{r, include = FALSE}
fit_arima_boxcox = Arima(M3[[id]]$x,order=c(2,1,3),seasonal=c(0,0,1), lambda = 'auto')
fit_arima_boxcox
```
$$\phi_{1bc} = 1,6428; \phi_{2bc} = -0,7597; \theta_{1bc} =-2,2962; \theta_{2bc} = 1,6333; \theta_{3bc} = -0,3207; \vartheta=0,2348$$

As previsões dos modelos:

```{r, fig.align="center", fig.cap="Previsões dos modelos ARIMA", echo = FALSE}
arima_layout <- layout(matrix(c(1,2),ncol=1), heights=c(20,20), TRUE)
fit_arima %>% forecast(h=24, level=c(80, 95)) %>% plot(xlab = "Arima(2,1,3)x(0,0,1)[12]", main = "")
fit_arima_boxcox %>% forecast(h=24, level=c(80, 95)) %>% plot(xlab = "Arima(2,1,3)x(0,0,1)[12] com Box-Cox", main = "")
```



